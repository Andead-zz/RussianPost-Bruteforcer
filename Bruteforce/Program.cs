/*
 * Структура российского трек кода выглядит так. Первые шесть цифр – это номер 
 * почтового отделения или почтовый индекс, далее следует двухзначный номер 
 * текущего месяца (начиная с 1.01.2000 года – январь 2000 года имеет номер 01). 
 * Эта двухзначная комбинация в данной структуре должны обеспечить уникальность 
 * почтового идентификатора в течение чуть более восьми лет (8 лет * 12 месяцев 
 * = 96, через четыре месяца двухзначный код становится невозможен). 
 * 
 * Следующие пять цифр – уникальный номер почтового отправления, не повторяющийся 
 * в течение календарного года. Завершает внутренний код контрольный разряд, 
 * вычисляемый как некая математическая функция от предыдущих цифр. Иногда в 
 * региональном коде отсутствует контрольный разряд, без которого отслеживание 
 * посылок по россии не представляется возможным. В таком случае не лишним будет 
 * знать технологию расчета контрольного разряда для 14-значного российского 
 * почтового кода. Допустим, наш код не содержит четырнадцатой цифры (если мы 
 * хотим проверить технологию расчета, то просто игнорируем четырнадцатую позицию – 
 * ее мы и будет определять). Складываем цифры, находящиеся на нечетных позициях, 
 * полученную сумму умножаем на три – получаем первый результат. 
 * 
 * Далее складываем цифры, стоящие на четных позициях, их сумма будет вторым 
 * результатом. Далее складываем первый и второй результаты и определяем 
 * минимальное число, которое необходимо добавить к последней сумме, чтобы 
 * получилось число, кратное десяти. Возьмем для примера следующий код: 
 * 11544679215342. В данном случае последняя цифра 2 – и есть контрольный разряд, 
 * правильность расчета которого мы и можем проверить. Сначала складываем нечетные 
 * позиции цифр: 1+5+4+7+2+5+4 = 28. Умножаем полученную сумму на 3: 28*3=84(первый 
 * результат). Далее складываем все четные позиции: 1+4+6+9+1+3=24 (второй результат). 
 * Складываем оба результата: 84+24=108. Для того, чтобы данная сумма стала кратной 
 * десяти, к ней необходимо добавить цифру 2 – это и есть наш контрольный разряд.
 * 
 * Источник: http://otvet.mail.ru/question/95361707?from=authpopup
 */

using System;
using System.IO;
using System.Linq;

namespace Bruteforce
{
    internal class Program
    {
        private static void Main()
        {
            // Код почтового отделения
            int[] of = {1, 9, 1, 1, 2, 3};

            // Месяц отправления, начиная с 1.01.2000 года – январь 2000 года имеет номер 01
            int[] mo = {8, 4};

            // Последняя цифра кода (контрольный разряд)
            const byte cb = 5;

            // Допустимое количество повторений одной цифры на протяжении уникального номера
            const int dupl = 0;

            // Разрешенный набор цифр для перебора в уникальном номере
            // Те цифры, которые отсутствуют, можно закомментировать - это уменьшит количество
            // полученных результатов
            byte[] x =
            {
                0,
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9
            };

            // Функция, проверяющая соответствие контрольного разряда коду с данным уникальным номером
            // 0 - все цифры различаются.
            Func<byte, byte, byte, byte, byte, bool> fits =
                (x1, x2, x3, x4, x5) =>
                    (3*(of[0] + of[2] + of[4] + mo[0] + x1 + x3 + x5) + of[1] + of[3] + of[5] + mo[1] + x2 + x4)%10 ==
                    cb;

            using (var sw = new StreamWriter("result.txt", false))
            {
                byte[] args = {x[0], x[0], x[0], x[0], x[0]};

                for (byte i = 0; i < x.Length; i++)
                {
                    args[0] = x[i];

                    for (byte j = 0; j < x.Length; j++)
                    {
                        args[1] = x[j];

                        for (byte k = 0; k < x.Length; k++)
                        {
                            args[2] = x[k];

                            for (byte m = 0; m < x.Length; m++)
                            {
                                args[3] = x[m];

                                for (byte n = 0; n < x.Length; n++)
                                {
                                    args[4] = x[n];

// ReSharper disable once RedundantLogicalConditionalExpressionOperand
                                    if (dupl < 5 && (args.Count(b => b == args[0]) > dupl + 1 ||
                                        args.Count(b => b == args[1]) > dupl + 1 ||
                                        args.Count(b => b == args[2]) > dupl + 1 ||
                                        args.Count(b => b == args[3]) > dupl + 1 ||
                                        args.Count(b => b == args[4]) > dupl + 1))
                                    {
                                        continue;
                                    }

                                    if (fits(x[i], x[j], x[k], x[m], x[n]))
                                    {
                                        sw.WriteLine("{0}{1}{2}{3}{4}{5}{6}{7}{8}{9}{10}{11}{12}{13}",
                                            of[0], of[1], of[2], of[3], of[4], of[5],
                                            mo[0], mo[1],
                                            x[i], x[j], x[k], x[m], x[n], cb);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}